// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract UnprotectedSelfDestruct {
    // This contract demonstrates the risk of an unprotected self-destruct function.

    // Mapping to store balances of users
    mapping(address => uint256) public balances;

    // Event to log deposits
    event Deposit(address indexed user, uint256 amount);

    // Event to log withdrawals
    event Withdraw(address indexed user, uint256 amount);

    // Constructor to set the owner of the contract
    constructor() {
        // Owner of the contract
        owner = msg.sender;
    }

    // Function to deposit Ether into the contract
    function deposit() external payable {
        // Update the balance of the sender
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    // Function to withdraw Ether from the contract
    function withdraw(uint256 amount) external {
        // Check if the user has enough balance
        require(balances[msg.sender] >= amount, "Insufficient balance");

        // Update the balance before transferring to prevent reentrancy attacks
        balances[msg.sender] -= amount;

        // Transfer the amount to the sender
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");

        emit Withdraw(msg.sender, amount);
    }

    // Vulnerable self-destruct function
    function destroy() external {
        // Self-destruct the contract and send remaining Ether to the sender
        selfdestruct(payable(msg.sender));
    }

    // Fallback function to accept Ether
    receive() external payable {}
}
______
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ProtectedSelfDestruct {
    // This contract demonstrates how to protect the self-destruct function.

    // Owner of the contract
    address public owner;

    // Mapping to store balances of users
    mapping(address => uint256) public balances;

    // Event to log deposits
    event Deposit(address indexed user, uint256 amount);

    // Event to log withdrawals
    event Withdraw(address indexed user, uint256 amount);

    // Modifier to restrict access to the owner
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    // Constructor to set the owner of the contract
    constructor() {
        owner = msg.sender;
    }

    // Function to deposit Ether into the contract
    function deposit() external payable {
        // Update the balance of the sender
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    // Function to withdraw Ether from the contract
    function withdraw(uint256 amount) external {
        // Check if the user has enough balance
        require(balances[msg.sender] >= amount, "Insufficient balance");

        // Update the balance before transferring to prevent reentrancy attacks
        balances[msg.sender] -= amount;

        // Transfer the amount to the sender
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");

        emit Withdraw(msg.sender, amount);
    }

    // Secure self-destruct function
    function destroy() external onlyOwner {
        // Self-destruct the contract and send remaining Ether to the owner
        selfdestruct(payable(owner));
    }

    // Function to change the owner of the contract
    function changeOwner(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid address");
        owner = newOwner;
    }

    // Fallback function to accept Ether
    receive() external payable {}
}

Explanation:

    Unprotected Self-Destruct:
        The selfdestruct function in Solidity allows a contract to delete itself and send all remaining Ether to a specified address. If this function is not properly protected, any user can call it and destroy the contract, potentially causing a loss of funds and data.

    Vulnerability:
        In the UnprotectedSelfDestruct contract, the destroy function allows anyone to call selfdestruct, which can lead to loss of funds and destruction of the contract by an unauthorized user.

    Mitigation:
        Use the onlyOwner modifier to restrict access to the selfdestruct function, ensuring that only the contract owner can call it.

    Steps:
        The ProtectedSelfDestruct contract defines an owner and uses the onlyOwner modifier to protect the destroy function.
        The changeOwner function allows the owner to transfer ownership to a new address securely.
        The deposit and withdraw functions allow users to deposit and withdraw Ether from the contract.
        The selfdestruct function is secured by the onlyOwner modifier, ensuring that only the contract owner can destroy the contract.

